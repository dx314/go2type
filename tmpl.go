package main

// TemplateData is the data passed to the template for generating the TypeScript file
type TemplateData struct {
	Version          string
	Timestamp        string
	Types            []TypeInfo
	Handlers         []HandlerInfo
	AuthToken        string
	AuthTokenStorage string
	UseHooks         bool
	UseReactQuery    bool
	UseDateObject    bool
}

const headerTemplate = `// This file is auto-generated. DO NOT EDIT.
// Generated by go2type {{.Version}} on {{.Timestamp}}
{{$useDateObject := .UseDateObject}}
{{if .UseReactQuery}}
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions, UseMutationResult, UseQueryResult } from '@tanstack/react-query'
{{else if .UseHooks}}
import { useState, useEffect, useCallback } from 'react'
{{end}}

{{if $useDateObject}}// Utility function to parse dates
const parseDate = (dateString: string): Date => new Date(dateString);
{{end}}
// Custom error class for API errors
export class APIError extends Error {
  constructor(public status: number, public statusText: string, public data: Record<string, unknown> | string) {    
    super(` + "`API Error ${status}: ${statusText}`" + `);
    this.name = 'APIError';
  }
}
`

// Update the template to use the new IsOptional field
const typesTemplate = `{{range .Types}}export type {{firstWord .Name}} = { {{range .Fields}}
  {{.Name}}{{if .IsOptional}}?{{end}}: {{.Type}};{{end}}
}
{{end}}
`

const queryFunctionTemplate = `{{$authToken := .AuthToken}}
{{$authTokenStorage := .AuthTokenStorage}}
{{$useDateObject := .UseDateObject}}

// Generic query factory
async function createQuery<TInput, TOutput>(
  method: string,
  url: string,
  input?: TInput,
  headers: Record<string, string> = {}
): Promise<TOutput> {
  const token = {{$authTokenStorage}}.getItem("{{$authToken}}");
  const defaultHeaders: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (token) {
    headers['Authorization'] = ` + "`Bearer ${token}`" + `;
  }

  const requestHeaders = { ...defaultHeaders, ...headers };
  const requestOptions: RequestInit = {
    method,
    headers: requestHeaders,
  };

  if (method !== 'GET' && input) {
    requestOptions.body = JSON.stringify(input);
  }

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      let errorData;
      try {
        errorData = await response.json();
      } catch {
        errorData = await response.text();
      }
      throw new APIError(response.status, response.statusText, errorData);
    }

    const data = await response.json();
    {{if $useDateObject}}
    // Parse dates in the response
    return JSON.parse(JSON.stringify(data), (key, value) =>
      typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value) ? parseDate(value) : value
    ) as TOutput;
    {{else}}
    return data as TOutput;
    {{end}}
  } catch (error) {
    if (error instanceof APIError) {
      throw error;
    } else if (error instanceof Error) {
      throw new APIError(0, 'Network Error', error.message);
    } else {
      throw new APIError(0, 'Unknown Error', String(error));
    }
  }
}

{{range .Handlers}}
export const {{.Name}}Query = async ({{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if .InputType}}input: {{.InputType}}{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}: string{{end}}): Promise<{{.OutputType}}> => {
  {{if .URLParams}}let{{else}}const{{end}} url = '{{.Path}}'
  {{range .URLParams}}
  url = url.replace(':{{.}}', encodeURIComponent({{.}}))
  {{end}}
  {{if and (eq .Method "GET") .InputType}}
  url += '?' + new URLSearchParams(input as any)
  {{end}}

  const headers: Record<string, string> = {};
  {{range .Headers}}
  {{if eq .Source "input"}}
  if ({{.SafeName}}) {
    headers['{{.OriginalName}}'] = {{.SafeName}};
  }
  {{else if eq .Source "localStorage"}}
  const {{.SafeName}}Value = localStorage.getItem('{{.OriginalName}}');
  if ({{.SafeName}}Value) {
    headers['{{.OriginalName}}'] = {{.SafeName}}Value;
  }
  {{else if eq .Source "sessionStorage"}}
  const {{.SafeName}}Value = sessionStorage.getItem('{{.OriginalName}}');
  if ({{.SafeName}}Value) {
    headers['{{.OriginalName}}'] = {{.SafeName}}Value;
  }
  {{end}}
  {{end}}

  return createQuery<{{if .InputType}}{{.InputType}}{{else}}void{{end}}, {{.OutputType}}>('{{.Method}}', url, {{if .InputType}}input{{else}}undefined{{end}}, headers);
};
{{end}}
`

const reactQueryHookTemplate = `{{range .Handlers}}
// React Query hook
{{if eq .Method "GET"}}
export const use{{.Name}} = (
  {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if .InputType}}input: {{.InputType}}{{if inputHeaders .Headers}}, {{end}}{{end}}
  {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}: string{{end}}{{if or .URLParams .InputType (inputHeaders .Headers)}}, {{end}}
  options?: Omit<UseQueryOptions<{{.OutputType}}, APIError>, 'queryKey' | 'queryFn'>
): UseQueryResult<{{.OutputType}}, APIError> =>
  useQuery<{{.OutputType}}, APIError>({
    queryKey: ['{{.Name}}'{{if .URLParams}}{{range .URLParams}}, {{.}}{{end}}{{end}}{{if .InputType}}, input{{end}}{{range inputHeaders .Headers}}, {{.SafeName}}{{end}}],
    queryFn: () => {{.Name}}Query({{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if and .URLParams .InputType}}, {{end}}{{end}}{{if .InputType}}input{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}{{end}}),
    ...options,
  });
{{else}}
export const use{{.Name}} = (
  {{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}
  {{if inputHeaders .Headers}}{{if .URLParams}}, {{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}: string{{end}}{{end}}
  {{if or .URLParams (inputHeaders .Headers)}}, {{end}}
  options?: Omit<UseMutationOptions<{{.OutputType}}, APIError, {{if .InputType}}{{.InputType}}{{else}}void{{end}}>, 'mutationFn'>
): UseMutationResult<{{.OutputType}}, APIError, {{if .InputType}}{{.InputType}}{{else}}void{{end}}> =>
  useMutation<{{.OutputType}}, APIError, {{if .InputType}}{{.InputType}}{{else}}void{{end}}>({
    mutationFn: ({{if .InputType}}input{{end}}) => {{.Name}}Query(
      {{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}
      {{if and .URLParams .InputType}}, {{end}}
      {{if .InputType}}input{{end}}
      {{if inputHeaders .Headers}}{{if or .URLParams .InputType}}, {{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}{{end}}{{end}}
    ),
    ...options,
  });
{{end}}
{{end}}
`

const reactHookTemplate = `{{range .Handlers}}
// Custom React hook
export const use{{.Name}} = (
  {{if eq .Method "GET"}}{{if .InputType}}input: {{.InputType}}{{end}}{{if inputHeaders .Headers}}, {{end}}{{end}}
  {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}
  {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}: string{{end}}
) => {
  const [data, setData] = useState<{{.OutputType}} | null>(null);
  const [error, setError] = useState<APIError | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const {{if eq .Method "GET"}}query = useCallback(async () => {{ "{" }}{{else}}mutate = useCallback(async ({{if .InputType}}input: {{.InputType}},{{end}}) => {{ "{" }}{{end}}
    setIsLoading(true);
    try {
      const result = await {{.Name}}Query(
        {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}
        {{if .InputType}}input{{end}}{{if inputHeaders .Headers}}, {{end}}
        {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}{{end}}
      );
      setData(result);
      setError(null);
      return result;
    } catch (e) {
      setError(e as APIError);
      setData(null);
      throw e;
    } finally {
      setIsLoading(false);
    }
  }, [{{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if and .InputType (eq .Method "GET")}}input{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.SafeName}}{{end}}]);

  {{if eq .Method "GET"}}
  useEffect(() => {
    query();
  }, [query]);
  {{end}}

  return { data, error, isLoading, {{if eq .Method "GET"}}query{{else}}mutate{{end}} };
};
{{end}}
`

const queryDictionaryTemplate = `
// Query dictionary
export const queries = {
  {{range .Handlers}}{{.Name}}: {{.Name}}Query,
  {{end}}
} as const;
`
