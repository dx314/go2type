package main

// TemplateData is the data passed to the template for generating the TypeScript file
type TemplateData struct {
	Version       string
	Timestamp     string
	Types         []TypeInfo
	Handlers      []HandlerInfo
	AuthToken     string
	UseHooks      bool
	UseReactQuery bool
	UseDateObject bool
}

const headerTemplate = `// This file is auto-generated. DO NOT EDIT.
// Generated by go2type {{.Version}} on {{.Timestamp}}
{{$useDateObject := .UseDateObject}}
{{if .UseReactQuery}}
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query'
{{else if .UseHooks}}
import { useState, useEffect, useCallback } from 'react'
{{end}}

{{if $useDateObject}}// Utility function to parse dates
const parseDate = (dateString: string): Date => new Date(dateString);
{{end}}
// Custom error class for API errors
export class APIError extends Error {
  constructor(public status: number, public statusText: string, public data: Record<string, unknown> | string) {    
    super(` + "`API Error ${status}: ${statusText}`" + `);
    this.name = 'APIError';
  }
}
`

const typesTemplate = `{{range .Types}}export type {{.Name}} = { {{range .Fields}}
  {{.Name}}: {{.Type}};{{end}}
}
{{end}}
`

const queryFunctionTemplate = `{{$authToken := .AuthToken}}
{{$useDateObject := .UseDateObject}}
{{range .Handlers}}
// Separate query function
export const {{.Name}}Query = async ({{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if .InputType}}input: {{.InputType}}{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}: string{{end}}): Promise<{{.OutputType}}> => {
  const token = localStorage.getItem("{{$authToken}}");
  {{if .URLParams}}let{{else}}const{{end}} url = '{{.Path}}'
  {{range .URLParams}}url = url.replace(':{{.}}', encodeURIComponent({{.}}))
  {{end}}
  {{if and (eq .Method "GET") .InputType}}
  url += '?' + new URLSearchParams(input as any){{end}}
  try {
    const headers = {
      'Authorization': token ? ` + "`Bearer ${token}`" + `: "",
      'Content-Type': 'application/json',
      {{range .Headers}}
      '{{.Name}}': {{if eq .Source "input"}}{{.Name}}{{else if eq .Source "localStorage"}}localStorage.getItem('{{.Name}}'){{else if eq .Source "sessionStorage"}}sessionStorage.getItem('{{.Name}}'){{end}} || '',
      {{end}}
    };
    const response = await fetch(url, {
      method: '{{.Method}}',
      headers,
      {{if and (ne .Method "GET") .InputType}}
      body: JSON.stringify(input),
      {{end}}
    });

    if (!response.ok) {
      let errorData;
      try {
        errorData = await response.json();
      } catch {
        errorData = await response.text();
      }
      throw new APIError(response.status, response.statusText, errorData);
    }

    const data = await response.json();
    {{if $useDateObject}}// Parse dates in the response
    return JSON.parse(JSON.stringify(data), (key, value) =>
      typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value) ? parseDate(value) : value
    ) as {{.OutputType}};
	{{else}}return data as {{.OutputType}};{{end}}
  } catch (error) {
    if (error instanceof APIError) {
      throw error;
    } else if (error instanceof Error) {
      throw new APIError(0, 'Network Error', error.message);
    } else {
      throw new APIError(0, 'Unknown Error', String(error));
    }
  }
};
{{end}}
`

const reactQueryHookTemplate = `{{range .Handlers}}
// React Query hook
{{if eq .Method "GET"}}
export const use{{.Name}} = (
  {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if .InputType}}input: {{.InputType}}{{if inputHeaders .Headers}}, {{end}}{{end}}
  {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}: string{{end}}{{if or .URLParams .InputType (inputHeaders .Headers)}}, {{end}}
  options?: Omit<UseQueryOptions<{{.OutputType}}, APIError>, 'queryKey' | 'queryFn'>
) =>
  useQuery<{{.OutputType}}, APIError>({
    queryKey: ['{{.Name}}'{{if .URLParams}}{{range .URLParams}}, {{.}}{{end}}{{end}}{{if .InputType}}, input{{end}}{{range inputHeaders .Headers}}, {{.Name}}{{end}}],
    queryFn: () => {{.Name}}Query({{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if and .URLParams .InputType}}, {{end}}{{end}}{{if .InputType}}input{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}{{end}}),
    ...options,
  });	
{{else}}
export const use{{.Name}} = (
  {{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}
  {{if inputHeaders .Headers}}{{if .URLParams}}, {{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}: string{{end}}{{end}}
  {{if or .URLParams (inputHeaders .Headers)}}, {{end}}
  options?: Omit<UseMutationOptions<{{.OutputType}}, APIError, {{if .InputType}}{{.InputType}}{{else}}void{{end}}>, 'mutationFn'>
) =>
  useMutation<{{.OutputType}}, APIError, {{if .InputType}}{{.InputType}}{{else}}void{{end}}>({
    mutationFn: ({{if .InputType}}input{{end}}) => {{.Name}}Query(
      {{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}
      {{if and .URLParams .InputType}}, {{end}}
      {{if .InputType}}input{{end}}
      {{if inputHeaders .Headers}}{{if or .URLParams .InputType}}, {{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}{{end}}{{end}}
    ),
    ...options,
  });
{{end}}
{{end}}
`

const reactHookTemplate = `{{range .Handlers}}
// Custom React hook
export const use{{.Name}} = (
  {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}: string{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}
  {{if .InputType}}input: {{.InputType}}{{if inputHeaders .Headers}}, {{end}}{{end}}
  {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}: string{{end}}
) => {
  const [data, setData] = useState<{{.OutputType}} | null>(null);
  const [error, setError] = useState<APIError | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const {{if eq .Method "GET"}}query{{else}}mutate{{end}} = useCallback(async ({{if and (ne .Method "GET") .InputType}}mutateInput?: {{.InputType}}{{end}}) => {
    setIsLoading(true);
    try {
      const result = await {{.Name}}Query(
        {{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}
        {{if .InputType}}{{if eq .Method "GET"}}input{{else}}mutateInput || input{{end}}{{if inputHeaders .Headers}}, {{end}}{{end}}
        {{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}{{end}}
      );
      setData(result);
      setError(null);
      return result;
    } catch (e) {
      setError(e as APIError);
      setData(null);
      throw e;
    } finally {
      setIsLoading(false);
    }
  }, [{{if .URLParams}}{{range $index, $param := .URLParams}}{{if $index}}, {{end}}{{$param}}{{end}}{{if or .InputType (inputHeaders .Headers)}}, {{end}}{{end}}{{if .InputType}}input{{if inputHeaders .Headers}}, {{end}}{{end}}{{range $index, $header := inputHeaders .Headers}}{{if $index}}, {{end}}{{$header.Name}}{{end}}]);

  {{if eq .Method "GET"}}
  useEffect(() => {
    query();
  }, [query]);
  {{end}}

  return { data, error, isLoading, {{if eq .Method "GET"}}query{{else}}mutate{{end}} };
};
{{end}}
`

const queryDictionaryTemplate = `
// Query dictionary
export const queries = {
  {{range .Handlers}}{{.Name}}: {{.Name}}Query,
  {{end}}
} as const;
`
